"""
Vulnerability Analyzer Module
Analyzes and scores vulnerabilities found during scans
"""

import logging
import json
import requests
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import numpy as np
from sklearn.preprocessing import MinMaxScaler

logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    def __init__(self):
        self.cve_cache = {}
        self.exploit_db = self._load_exploit_db()
        self.risk_weights = {
            'cvss_score': 0.4,
            'exploit_available': 0.3,
            'age': 0.2,
            'patch_available': 0.1
        }
    
    def _load_exploit_db(self) -> Dict:
        """Load exploit database (simplified version)"""
        # In production, this would connect to exploit databases
        # like ExploitDB, Metasploit modules, etc.
        return {
            'CVE-2021-44228': {'exploit': True, 'name': 'Log4Shell'},
            'CVE-2021-34527': {'exploit': True, 'name': 'PrintNightmare'},
            'CVE-2020-1472': {'exploit': True, 'name': 'Zerologon'},
            # Add more known exploits
        }
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate comprehensive risk score for a host"""
        if not vulnerabilities:
            return {
                'score': 0,
                'level': 'none',
                'factors': {}
            }
        
        scores = []
        critical_count = 0
        high_count = 0
        exploitable_count = 0
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('id')
            cvss = vuln.get('cvss', 0)
            
            # Check if exploit exists
            has_exploit = cve_id in self.exploit_db
            if has_exploit:
                exploitable_count += 1
            
            # Count by severity
            if cvss >= 9.0:
                critical_count += 1
            elif cvss >= 7.0:
                high_count += 1
            
            # Calculate individual score
            vuln_score = self._calculate_vuln_score(vuln, has_exploit)
            scores.append(vuln_score)
        
        # Calculate aggregate score
        if scores:
            # Use weighted average with emphasis on highest scores
            scores.sort(reverse=True)
            weights = [1.0 / (i + 1) for i in range(len(scores))]
            weighted_score = np.average(scores[:min(10, len(scores))], 
                                       weights=weights[:min(10, len(scores))])
        else:
            weighted_score = 0
        
        # Determine risk level
        if weighted_score >= 9.0 or critical_count > 0:
            level = 'critical'
        elif weighted_score >= 7.0 or high_count >= 3:
            level = 'high'
        elif weighted_score >= 4.0:
            level = 'medium'
        elif weighted_score > 0:
            level = 'low'
        else:
            level = 'none'
        
        return {
            'score': round(weighted_score, 2),
            'level': level,
            'factors': {
                'total_vulnerabilities': len(vulnerabilities),
                'critical_count': critical_count,
                'high_count': high_count,
                'exploitable_count': exploitable_count,
                'max_cvss': max((v.get('cvss', 0) for v in vulnerabilities), default=0)
            }
        }
    
    def _calculate_vuln_score(self, vuln: Dict, has_exploit: bool) -> float:
        """Calculate score for individual vulnerability"""
        cvss = vuln.get('cvss', 0)
        
        # Base score from CVSS
        score = cvss
        
        # Increase score if exploit is available
        if has_exploit:
            score *= 1.5
        
        # Consider age (newer vulnerabilities might be more dangerous)
        # This is simplified - in production, would check actual CVE dates
        cve_year = self._extract_cve_year(vuln.get('id', ''))
        if cve_year:
            current_year = datetime.now().year
            age_factor = max(0, 1 - (current_year - cve_year) * 0.1)
            score *= (1 + age_factor * 0.2)
        
        return min(10, score)  # Cap at 10
    
    def _extract_cve_year(self, cve_id: str) -> Optional[int]:
        """Extract year from CVE ID"""
        try:
            # CVE format: CVE-YYYY-NNNNN
            parts = cve_id.split('-')
            if len(parts) >= 2:
                return int(parts[1])
        except:
            pass
        return None
    
    def get_remediation_priority(self, hosts: List[Dict]) -> List[Dict]:
        """Generate remediation priority list"""
        priority_list = []
        
        for host in hosts:
            if not host.get('cves'):
                continue
            
            risk_score = self.calculate_risk_score(host['cves'])
            
            # Calculate business impact (simplified)
            business_impact = self._estimate_business_impact(host)
            
            # Calculate remediation effort
            effort = self._estimate_remediation_effort(host['cves'])
            
            # Priority score: high risk, high impact, low effort = high priority
            priority_score = (risk_score['score'] * 0.5 + 
                            business_impact * 0.3) / (effort + 1)
            
            priority_list.append({
                'host': host['ip'],
                'hostname': host.get('hostname'),
                'risk_score': risk_score['score'],
                'risk_level': risk_score['level'],
                'business_impact': business_impact,
                'remediation_effort': effort,
                'priority_score': round(priority_score, 2),
                'vulnerabilities': len(host['cves']),
                'recommendations': self._generate_recommendations(host['cves'])
            })
        
        # Sort by priority score
        priority_list.sort(key=lambda x: x['priority_score'], reverse=True)
        
        return priority_list
    
    def _estimate_business_impact(self, host: Dict) -> float:
        """Estimate business impact of host compromise"""
        impact = 5.0  # Base impact
        
        # Check for critical services
        critical_services = ['ssh', 'rdp', 'http', 'https', 'smtp', 'ldap', 'sql']
        if host.get('ports'):
            for port in host['ports']:
                if port.get('service') in critical_services:
                    impact += 1.0
        
        # Check if it's a server OS
        os_info = host.get('os', '').lower()
        if 'server' in os_info or 'enterprise' in os_info:
            impact += 2.0
        
        return min(10, impact)
    
    def _estimate_remediation_effort(self, vulnerabilities: List[Dict]) -> float:
        """Estimate effort required to remediate vulnerabilities"""
        if not vulnerabilities:
            return 0
        
        effort = len(vulnerabilities) * 0.5  # Base effort per vulnerability
        
        # Check for complex vulnerabilities
        for vuln in vulnerabilities:
            cve_id = vuln.get('id', '')
            
            # Some vulnerabilities require more effort
            if 'kernel' in vuln.get('description', '').lower():
                effort += 2.0  # Kernel updates require reboots
            elif 'configuration' in vuln.get('description', '').lower():
                effort += 0.5  # Config changes are easier
        
        return min(10, effort)
    
    def _generate_recommendations(self, vulnerabilities: List[Dict]) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []
        
        # Group vulnerabilities by type
        has_critical = any(v.get('cvss', 0) >= 9.0 for v in vulnerabilities)
        has_exploit = any(v.get('id') in self.exploit_db for v in vulnerabilities)
        
        if has_critical:
            recommendations.append("URGENT: Patch critical vulnerabilities immediately")
        
        if has_exploit:
            recommendations.append("HIGH PRIORITY: Known exploits exist - patch or isolate affected systems")
        
        # Add specific recommendations based on CVEs
        for vuln in vulnerabilities[:5]:  # Top 5 vulnerabilities
            cve_id = vuln.get('id')
            if cve_id in self.exploit_db:
                recommendations.append(f"Patch {cve_id} ({self.exploit_db[cve_id].get('name', 'Unknown')})")
        
        if not recommendations:
            recommendations.append("Regular patching schedule recommended")
        
        return recommendations

